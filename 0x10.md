# Editor
在中间某个位置进行操作，使用对顶栈模拟
# 进出栈序列问题
卡特兰数，注意大数乘法
# Largest Rectangle in a Histogram
以某个点为高找两侧第一个小于它的点，可以一次遍历，因此次栈顶的位置刚好是左边第一个小于它的位置，每次入栈要弹出的时候时候统计长度即可
# Team Queue
使用队列模拟，用第一个队列记录队伍的情况，其他队列记录每个组的情况
# 蚯蚓
用`delta`维护整个集合的偏移量，取出时用`x+delta`，放进去时多减去一个`q`，表示其他都增长了`q`。另外有个单调性就是先后取出的`i`，`j`，之后取出顺序也会是先`i`再`j`，因此用三个队列维护大到小的关系
# 双端队列
考虑将原来的数组排好序后分段到不同的双端队列，每个队列能分的最多的就是一个单谷（先减再增）的形式
# 最大子序和
单调队列，双端队列，前缀和后只保留较近的最小值
# 邻值查找
用`treeset`维护前面的关系
# Snowflake Snow Snowflakes
`A+B`问题，自定义`hash`和`equals`
# 兔子与兔子
字符串`hash`，`java`没有`unsigned`，如果不用`mod`可以在溢出为负数的时候减去`Long.MIN_VALUE`
# Palindrome
前后缀字符串`hash`然后分奇偶串二分答案，在元素中插入中间变量可以不用考虑就，也可以用`manacher`算法
# 后缀数组
利用字符串`hash`，二分两个字符串找到最长的公共前缀，比较后一个字符串即可得到两个字符串的大小，因此`hash`后直接排序
# Period
`kmp`，当`i-next[i]`能够整除`i`时候,那么`s[1~i-next[i]]`就是`s[i-1]`的最小循环元
# 前缀统计
构建`Trie`树，数前缀
# The XOR Largest Pair
构建`Trie`树，异或按照不同的位走，如果没有则按相同的走
# The xor-longest Path
构建树，统计根节点到每个节点的异或值，不同的两个点路径的值为`a[i]^a[j]`
# Supermarket
在不过期的时间内优先卖出利润更大的产品
# Sequence
每次计算两个数组，维护下标位置，最小的拿出来,比如是`x,y`，后面将`x+1,y`和`x,y+1`放进去，要注意`(1,2)`，`(2,1)`都可以转移到`(2,2)`，需要排除重复
# 数据备份
抽象为在`n-1`个相邻的差距中选`k`个，且这`k`个不能相邻，对于其中最小的一个元素，要么选，要么不选且同时选其两边的

具体操作可以先选一个最小的`d[x]`，然后将`d[x-1]+d[x+1]-d[x]`放进去（选到则说明是选最小值旁边的两个）。用双端队列模拟这个过程，删除不直接删除，而是记录是否访问过
# 合并果子
`huffman`树
# 荷马史诗
`k`叉`huffman`树，对叶子节点补`0`，使得`(n-1)%(k-1)=0`，最短可以在权值相等时优先考虑深度较低的
# 括号画家
在栈中记录字符坐标

也可以`dp`，`dp[i]`表示以`i`结尾的最长美观字段的长度
``` java
dp[i]=0 // i与i-1-dp[i-1]不匹配
dp[i]=dp[i-1]+2+dp[ i-1 - dp[i-1] -1] // i与i-1-dp[i-1]匹配
```
# 表达式计算4
栈模拟
# City Game
每次读入一个平面转换为矩阵柱，然后`stack`求最大矩形面积，[Largest Rectangle in a Histogram](https://github.com/humwawe/tedukuri/blob/master/0x10.md#largest-rectangle-in-a-histogram)
# 双栈排序
先判断每个元素应该在哪个栈里面，存在性质，对于`i<j`，如果有一个`k>j`使得`a[k]<a[i]<a[j]`，则`i`，`j`不能进入同一栈。根据此性质建图，不能再同一栈中连边，判断是否能二分图。如果可以二分图则模拟过程
# Sliding Window
单调双端对列，存下标，超出`k`移除，同时队尾与当前元素比较考虑是否移除

也可以考虑堆，存下标，当堆顶超出`k`移除，否则取堆顶，复杂度高一些
# 内存分配
模拟整个过程，每来一个考虑是否有可以结束的（优先队列），没弹出一个考虑队列里是否有可以加入的，用`treeset`维护顺序