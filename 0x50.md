# Mr. Young's Picture Permutations
记录每一排的个数，递推根据个数推
# LCIS
结合`LIS`和`LCS`，`dp[i][j]`表示`a[1]`到`a[i]`和`b[1]`到`b[j]`且以`b[j]`结尾的`LCIS`长度
``` java
f[i][j]=f[i−1][j]   // (a[i]!=b[j])
f[i][j]=f[i−1][k]+1 // (a[i]==b[j]) k为j之前且值小于b[j]的位置
```
每次循环`i`的时候可以记录下当前小于`a[i]`的集合中的最大值，`O(1)`更新
# Making the Grade
构造的方案中，`b`中的数肯定是`a`中出现过的，因此`dp[i][j]`表示第`i`个数，值取`j`的情况，由`i-1`的状态转移，可以保存最小值`O(1)`转移
# Mobile Service
容易想到`dp[i][x][y][c]`的状态转移，考虑有一个人肯定位于`p[i]`处，因此可以减少一维`dp[i][x][y]`，表示一个位于`p[i]`，其余位于`x`或`y`处
# 传纸条
最小化`dp`，记录步数和两个纸条位置即可
# I-country
`dp[i][j][l][r][x][y]`表示前`i`行选了`j`个格子，第`i`行选`l`到`r`个格子，左边界单调性`x`，有边界单调性`y`
# Cookies
确定贪心的顺序后`dp`，贪婪度大的需要获得的饼干多，`dp[i][j]`表示前`i`个小孩发放了`j`个饼干，考虑相对的关系，`i`如果大于`1`，和`i`为`1`，且前面有`k`个`1`的情况的转移
# 数字组合
`0/1`背包
# 自然数拆分Lunatic版
完全背包
# Jury Compromise
`dp[i][j][k]`表示前`i`个选了`j`个，差异为`k`时的最大值
# Coins
朴素多重背包超时，考虑转换成完全背包，使用`used`数组实现多重背包中的限制
# 石子合并
区间`dp`，枚举长度或者倒着枚举
# Polygon
复制一遍解决环的问题，转换成石子合并问题，考虑区间的分割
# 金字塔
区间`dp`，遍历切分的点，考虑第一棵树的位置
# 没有上司的舞会
考虑某个节点去和不去的情况，通过子节点倒推
# 选课
树上分组背包，`dp[u][j]`表示对`u`节点选`j`个的情况
# Accumulation Degree
两次遍历，第一次以任意源点出发求出`d`数组，再一次以改点出发求出`f`数组（根据子树和往上的流向求出），注意处理叶节点
# Naptime
考虑`n`处是否睡觉，将环拆成两部分求解
# 环路运输
复制破环，以`n/2`的长度为界，寻找该窗口的最大值，使用双端队列维护
# Broken robot
考虑`N`次高斯消元递推下一行与上一行的关系，求每一行某个位置的期望
# Mondriaan's Dream
状压`dp[i][j]`表示第`i`行，`j`状态某一位为`1`表示为竖着的上面一半。（为`0`的时候对下一行没有影响）
# 炮兵阵地
当前状态可能受到上两行的影响，因此多一维维护上一行的状态，`dp[i][j][k]`表示第`i`行，状态为`j`，上一行状态为`k`的情况
# 宝藏
每次考虑一层的状态，扩展`n`层，预处理某一层是否能由其子集扩展，`dp[j][i]`表示扩展了`j`状态，最大深度为`i`的情况
# 开车旅行
倍增，记录每个`2`次方走的位置和路径
# Count the Repetitions
倍增`dp[i][j]`，表示从`j`开始匹配，如果匹配`2^i`个字符能匹配到多长
# Cleaning Shifts
线段树维护`dp`转移区间的最小值
# The Battle of Chibi
树状数组优化，每次加入一个值，求前面某个区间的值
# Fence
`dp[i][j]`表示第`i`个人刷前`j`个板的最大值，维护一段区间的最大值，单调队列优化
# Cut the Sequence
单调队列维护候选值，所有后选值放入堆中一一映射
# 任务安排1
将某一次的启动费用累加到之后的所有任务
# 任务安排2
斜率优化，单调队列，队头维护大于当前斜率的，队尾维护单调增的点（凸包）
# 任务安排3
斜率不再单增，考虑在队列维护的凸包中二分位置，`long*long`使用`double`避免溢出
# Cats Transport
按`t-d`排序后，转换为不超过`p`次的连续区间段，`dp[i][j]`表示`i`个人，取到前`j`个猫时的最小值，斜率优化
# 诗人小G
满足决策单调性，用队列维护决策三元组，开`long double`解决精度问题
# 再探石子合并
普通[石子合并](https://github.com/humwawe/tedukuri/blob/master/0x50.md#石子合并) ，区间`dp`复杂度`O(n^3)`，使用四边形优化`O(n^2)`，本题`N`比较大，`GarsiaWachs`算法为`O(NlogN)`
``` java
int[][] dp = new int[n + 2][n + 2];
int[][] p = new int[n + 1][n + 1];
for (int i = 1; i <= n; i++) {
    dp[i][i] = 0;
    p[i][i] = i;
}
for (int len = 2; len <= n; len++) {
    for (int i = 1; i + len - 1 <= n; i++) {
        int j = i + len - 1;
        dp[i][j] = inf;
        for (int k = p[i][j - 1]; k <= p[i + 1][j]; k++) {
            int v = dp[i][k] + dp[k + 1][j] + s[j] - s[i - 1];
            if (dp[i][j] > v) {
                dp[i][j] = v;
                p[i][j] = k;
            }
        }
    }
}
out.println(dp[1][n]);
```
# Gerald and Giant Chess
`N`比较小，从黑的位置入手，考虑第一次经过黑的位置为`j`，方案数为`f`，因此最后的个数为所有的个数减去第一次到某个黑位置（后面随意）的个数
# Connected Graph
边的总数是`n*(n-1)/2`，可选或不选因此总数为`2^(n*(n-1)/2)`，考虑对`i`个点，某一个联通图有`j`个点，对标号为`1`的点，从`i-1`个点中`j-1`个点组成连通图，剩下的从`i-j`个点中任意排列
# A decorative fence
使用相对顺序去递推，考虑第一个位置相对大小为`h`时，后面个数是否大于`c`，小于则考虑`h+1`
# 启示录
数位`dp`记录个数，用拼凑的方法考虑每一的值。`f[i][j]`由`i`个数构成的左边(高位)有`j`个`6`的数的个数，`g[i]`由`i`个数构成魔鬼数的个数

也可以二分，对每个二分的值考虑有多少个魔法值小于当前数
# 月之谜
数位`dp`，枚举各位和，当和等于当前值，且`mod`为`0`，计`1`
# 乌龟棋
四维`dp`，表示用了多少个`a`，`b`，`c`，`d`
# 花店橱窗
`dp[i][j]`表示前`i`个花瓶放了`j`朵花的最大值，考虑放和不放的转移，方案倒推
# BUY LOW BUY LOWER
对`LIS`的`dp`值统计方案
# Trip
求`LCS`，求方案枚举`a-z`，考虑最后一个字符可能是什么，记录每个字符在某个长度下的最晚出现位置
# Substract
转换为求正负号，先考虑正号位置，最后再补负号
# 陨石的秘密
`dp[i][j][k][d]`表示深度小于等于`d`，`i`对`{}`，`j`对`[]`，`k`对`()`的结果
# 划分大理石
多重背包求可行性，类似[Coins](https://github.com/humwawe/tedukuri/blob/master/0x50.md#coins)
# Folding
区间`dp`，枚举分割点考虑两部分加起来或者这部分可以代表整体的区间，方案按照`dp`值逆推
# 能量项链
区间`dp`，断环成链多考虑一位
# 棋盘分割
二维区间`dp`，化简所求式子，考虑横着切竖着切的最小值
# Blocks
区间`dp`，多一维记录右边相同的长度，这样消去某个中间的时候，可以直接将右边长度累加到前一个区间
# Strategic Game
树形`dp`，考虑某个点选择或者不选择的情况
# Bribing FIPA
树形`dp`，先求每个`size`，再根据`size`进行`dp`，枚举`size`要倒序
# Computer
两次`dp`，第一次记录最大值和次大值，并记录对应的点，第二次传递到父节点的最大值
# XOR和路径
公式可能依赖自己，且存在异或无法直接相加减，因此转换为位运算，考虑每一位，将异或转换为`0`和`1`
# corn field
状压`dp`，没有挨着可以`s&(s<<1)==0`，不重叠可以枚举异或后的子集
# Bugs Integrated Inc
三进制状压，某一位的数字表示向下延伸的情况，如果当前为`2`，则下一行必为`1`，`dfs`考虑当前状态能推出哪些状态
# Fence Obstacle Course
区间修改单点查询，找到当前区间端点被最近的区间包含的该区间`id`
# Estimation
`dp[i][j]`表示对`i`个划分`j`段的代价，中间的代价需要求中位数，使用两个堆来维护
# 干草堆
逆序，层数越高，底边越短，对某个`i`，`j`越大越好（`f[j]`递增）
# 股票交易
`f[i][j]`表示第`i`天有`j`个股票的价值，对某个区间的转移使用单调队列维护
# Largest Submatrix
考虑变成不同字母的最大子矩阵，子矩阵求法用单调栈
# K-Anonymous Sequence
考虑`i`可以由前面某个位置转移，写出公式，该位置可以斜率优化
# 特别行动队
`i`由前面某个位置转移，使用斜率优化维护上凸包
# Post Office
`dp[i][j]`，前`i`个用`j`个的最小值`dp[i][j] = dp[k][j-1] + w[k+1][i]`，`w`的求解可以递推，且满足四边形不等式，枚举`k`的时候可以优化
# 扑克牌
将状态记录为出现某种次数的牌的个数和上一次放的牌当前的个数
# The Counting Problem
数位`dp`，考虑小于某个数的某个值出现的次数
# Round Numbers
数位`dp`，可以计算`0`与`1`的差值（防止负数可以加偏移量），这样可以少一维
将所有联通块与`0`相连（使用每个联通块里最小的点），然后考虑某一条与`0`相连的边去替换