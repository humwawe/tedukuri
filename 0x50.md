# Mr. Young's Picture Permutations
记录每一排的个数，递推根据个数推
# LCIS
结合`LIS`和`LCS`，`dp[i][j]`表示`a[1]`到`a[i]`和`b[1]`到`b[j]`且以`b[j]`结尾的`LCIS`长度
``` java
f[i][j]=f[i−1][j]   // (a[i]!=b[j])
f[i][j]=f[i−1][k]+1 // (a[i]==b[j]) k为j之前且值小于b[j]的位置
```
每次循环`i`的时候可以记录下当前小于`a[i]`的集合中的最大值，`O(1)`更新
# Making the Grade
构造的方案中，`b`中的数肯定是`a`中出现过的，因此`dp[i][j]`表示第`i`个数，值取`j`的情况，由`i-1`的状态转移，可以保存最小值`O(1)`转移
# Mobile Service
容易想到`dp[i][x][y][c]`的状态转移，考虑有一个人肯定位于`p[i]`处，因此可以减少一维`dp[i][x][y]`，表示一个位于`p[i]`，其余位于`x`或`y`处
# 传纸条
最小化`dp`，记录步数和两个纸条位置即可
# I-country
`dp[i][j][l][r][x][y]`表示前`i`行选了`j`个格子，第`i`行选`l`到`r`个格子，左边界单调性`x`，有边界单调性`y`
# Cookies
确定贪心的顺序后`dp`，贪婪度大的需要获得的饼干多，`dp[i][j]`表示前`i`个小孩发放了`j`个饼干，考虑相对的关系，`i`如果大于`1`，和`i`为`1`，且前面有`k`个`1`的情况的转移
# 数字组合
`0/1`背包
# 自然数拆分Lunatic版
完全背包
# Jury Compromise
`dp[i][j][k]`表示前`i`个选了`j`个，差异为`k`时的最大值
# Coins
朴素多重背包超时，考虑转换成完全背包，使用`used`数组实现多重背包中的限制
# 石子合并
区间`dp`，枚举长度或者倒着枚举
# Polygon
复制一遍解决环的问题，转换成石子合并问题，考虑区间的分割
# 金字塔
区间`dp`，遍历切分的点，考虑第一棵树的位置
# 没有上司的舞会
考虑某个节点去和不去的情况，通过子节点倒推
# 选课
树上分组背包，`dp[u][j]`表示对`u`节点选`j`个的情况
# Accumulation Degree
两次遍历，第一次以任意源点出发求出`d`数组，再一次以改点出发求出`f`数组（根据子树和往上的流向求出），注意处理叶节点
# Naptime
考虑`n`处是否睡觉，将环拆成两部分求解
# 环路运输
复制破环，以`n/2`的长度为界，寻找该窗口的最大值，使用双端队列维护
# Broken robot
考虑`N`次高斯消元递推下一行与上一行的关系，求每一行某个位置的期望
# Mondriaan's Dream
状压`dp[i][j]`表示第`i`行，`j`状态某一位为`1`表示为竖着的上面一半。（为`0`的时候对下一行没有影响）
# 炮兵阵地
当前状态可能受到上两行的影响，因此多一维维护上一行的状态，`dp[i][j][k]`表示第`i`行，状态为`j`，上一行状态为`k`的情况