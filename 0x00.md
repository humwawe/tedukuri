# a^b
快速幂，倍增的思想
# 64位整数乘法
倍增，或者用大数乘
# 最短Hamilton路径
状态压缩`dp`，从`k`到`i`有`dp[st_i][i] = dp[st_k][k] + w[k][i]`，注意要保证`k`和`i`的状态是满足要求的
# 起床困难综合症
位运算从高到低考虑每一位的选`1`或者选`0`，选`1`会让结果变大，因此优先选`0`，记录之前的已选到的值，但选`1`更好且不超过`m`即可选`1`，否则选`0`
# 递归实现指数型枚举
枚举每个数是否选
# 递归实现组合型枚举
枚举每个数是否选择，注意剪枝，当超过`m`或不够`m`的时候提前退出
# 递归实现排列型枚举
每个位置选不同的值
# 费解的开关
考虑第一行不同的按法，判断后面是否能满足条件，当第一行确定了后面的按法就一定了
# Strange Towers of Hanoi
对于`3`柱问题`d[n] = 2 * d[n-1] + 1`，对于`4`柱`f[n] = min{2 * f[i] + d[n - i]}`
# Sumdiv
约数之后为`(p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)`，等比数列求和有除法，因此直接分治配合快速幂求
# Fractal Streets
`N`级城市，可以由`4`个`N−1`级城市构造，因此递归，再考虑坐标的变换
# 激光炸弹
前缀和
# IncDec Sequence
对区间操作转换为差分数组的操作，对区间操作相当于选位置进行加`1`和减`1`，每次贪心的选，剩余未配对的可以与第一个和最末边界的配对
# Tallest Cow
将每一对区间内部的牛高度减`1`，利用差分对两个端点操作，最后最高的应该仍然是`0`
# Best Cow Fences
二分平均值，将每个数减去该平均值，转换为求长度不小于`f`的字段，且该子段可以非负，非负说明平均值可以取到
# Cinema
语言编号大，可以考虑离散化或者用`map`存次数，然后对电影编号排序
# 货仓选址
选到中位数即可
# 七夕祭
改变两个相邻的只会改变行或列，因此两边可以独立运算。考虑转换为均分纸牌问题，将每个人的纸牌减去平均值，对每个前缀和的绝对值相加即是结果，由于可以环，因此考虑枚举断开的位置，最小位置即是中位数的位置
# Running Median
对顶堆，一个最大堆和最小堆，中位数存在最大堆中，允许最大堆的个数多一个。新来一个`x`，如果比中位数小，则放入最大堆，否则放入最小堆，调节个数平衡
# Ultra-QuickSort
归并排序求逆序对数量，也可以考虑树状数组
# 奇数码问题
排成一排后，看逆序对的数量
# Genius ACM
倍增的思想，考虑对某个`l`最远能到的满足校验值不超过`t`的`r`，`check`的时候需要排序，排序使用归并
# Sunscreen
贪心，按`minSPF`降序排，对每一个选满足条件的最大`SPF`，也可以对称的选，从小到大排序的排`maxSPF`，然后每次选最小的`SPF`
# Stall Reservations
排序，考虑每个元素的开头是否能接在最近结束的畜栏，否则新开一个
# Radar Installation
转换为区间选点的问题，排序后遍历，需要新开一个时将点放置在靠右的端点，否则放置在比较小的右端点处，保证该点能被覆盖
# 国王的游戏
按乘积大小排序即可，证明可以用微扰，考虑交换两个相邻的变化，可以看出乘积小的排在前面更好
# Color a Tree
考虑树中最大的点，要在其父节点染色后马上染色，因此每次找到最大的点向上合并，如此操作`n-1`次，最终会汇集到根节点，每次合并对结果的贡献为`nodes[u].sum * nodes[fa].size`